(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();

    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
      window.ScrollHover = factory();
    }
  } else {
    // Browser globals (root is window)
    root.ScrollHover = factory();
  }
})(void 0, function () {
  return (
    /*#__PURE__*/
    function () {
      function ScrollHover(params) {
        _classCallCheck(this, ScrollHover);

        this.wrap = params.wrap;
        this.content = params.content;
        this.pxPreSec = params.pxPreSec || 100;
        this.scope_attr = 'scrollhoverscope';
        this.init();
      } // Служебный метод, нужен для генерации scopedID


      _createClass(ScrollHover, [{
        key: "rand",
        value: function rand(min, max) {
          var rand = Math.floor(min + Math.random() * (max + 1 - min));
          return rand;
        } // Служебный метод, генерирующий атрибут для изоляции стилей

      }, {
        key: "scopedIdGenerate",
        value: function scopedIdGenerate() {
          var id = '';

          for (var i = 0; i < 10; i++) {
            id += String.fromCharCode(this.rand(97, 122));
          }

          return id;
        } // Метод, шаблонизирующий стили для скролла по ховеру. 
        // Подставляет значения, которые нужны для равномерной скорости скролла различного
        // объема контента в контейнерах различной высоты

      }, {
        key: "getStyleTemplate",
        value: function getStyleTemplate(scope, duration, translate_y) {
          return "\n            ".concat(this.wrap, "[data-").concat(this.scope_attr, "=").concat(scope, "] .content {\n                transition: transform ").concat(duration, "ms linear;\n                will-change: transform;\n            }\n    \n            ").concat(this.wrap, "[data-").concat(this.scope_attr, "=").concat(scope, "]:hover .content {\n                transform: translate3d(0, ").concat(translate_y, "px, 1px);\n            }");
        } // Метод, создающий элемент стилей внутри контейнера.
        // Выполняет все расчеты для обеспечения нужной скорости скролла

      }, {
        key: "makeStyle",
        value: function makeStyle(wrap, content) {
          // Генерируем атрибут изоляции стилей
          var scope = this.scopedIdGenerate();
          wrap.dataset[this.scope_attr] = scope; // Получаем высоту контента

          var content_height = parseInt(getComputedStyle(content).height); // Получаем высоту контейнера и на ее основе получаем 
          // максимальное значение сдвига контента

          var wrap_height = parseInt(getComputedStyle(wrap).height);
          var translate_y = wrap_height - content_height; // Если высота контента меньше высоты контейнера, то ничего двигать не надо

          translate_y = translate_y < 0 ? translate_y : 0; // Зная величину сдвига, получаем длительность transition,
          // чтобы обеспечить стабильную скорость скролла

          var duration = Math.abs(translate_y) / this.pxPreSec * 1000; // Из полученных данных генерируем индивидуальные стили

          var style = document.createElement('style');
          style.textContent = this.getStyleTemplate(scope, duration, translate_y); // И добавляем их в свой контейнер

          wrap.appendChild(style);
        }
      }, {
        key: "init",
        value: function init() {
          var _this = this;

          // На документ вешаем обработчик на событие захода мыши на элемент
          document.addEventListener('mouseover', function (e) {
            // Если мышь попала на блок контента
            if (e.target.classList.contains(_this.wrap.substring(1))) {
              var wrap = e.target;
              var content = wrap.querySelector(_this.content); // И если в контейнере этого контента еще нет стилей для его скролла

              if (!wrap.querySelector('style')) {
                // То запустим создание этих стилей
                _this.makeStyle(wrap, content);
              }
            }
          });
        }
      }]);

      return ScrollHover;
    }()
  );
});

},{}]},{},[1])

//# sourceMappingURL=maps/scroll-hover.min.js.map
